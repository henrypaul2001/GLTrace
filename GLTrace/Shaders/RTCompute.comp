#version 430 core
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D screenImage;

const float pi = 3.1415926535897932385;
const uint max_world_size = 100;

// Utility
uint xorshift32_state = 0x12345678; // Example seed
uint xorshift32() {
	uint x = xorshift32_state;
	x ^= x << 13;
	x ^= x >> 17;
	x ^= x << 5;
	return xorshift32_state = x;
}
float fast_random() {
	return (xorshift32() / 100000000000000000000000000000000000000.0);
}
float fast_random(float fmin, float fmax) {
	return fmin + (fmax - fmin) * fast_random();
}
float length_squared(vec3 vec) {
	return vec.x * vec.x + vec.y * vec.y + vec.z * vec.z;
}
vec3 fast_random_in_unit_disk() {
	// Generate a random angle theta and random radius squared (r^2) for uniform distribution
	float theta = fast_random(0.0, 2.0 * pi);
	float r = sqrt(fast_random(0.0f, 1.0));  // sqrt ensures uniform sampling over the disk

	// Convert polar coordinates (r, theta) to Cartesian coordinates (x, y)
	float x = r * cos(theta);
	float y = r * sin(theta);

	// Return the point in the unit disk (z is always 0)
	return vec3(x, y, 0.0f);
}
vec3 fast_random_unit_vector() {
	float theta = fast_random(0.0, 2.0 * pi);
	float phi = acos(fast_random(-1.0, 1.0));  // acos to sample evenly on a sphere
	float x = sin(phi) * cos(theta);
	float y = sin(phi) * sin(theta);
	float z = cos(phi);
	return vec3(x, y, z);
}
vec3 fast_random_on_hemisphere(vec3 normal) {
	vec3 on_unit_sphere = fast_random_unit_vector();
	if (dot(on_unit_sphere, normal) > 0.0) {
		return on_unit_sphere;
	}
	else {
		return -on_unit_sphere;
	}
}

struct ray {
	vec3 origin;
	vec3 direction;
};
ray new_ray(vec3 origin, vec3 direction) {
	ray r;
	r.origin = origin;
	r.direction = direction;
	return r;
}
vec3 at(ray r, float t) {
	return r.origin + t * r.direction;
}

struct interval {
	float tmin;
	float tmax;
};
interval new_interval() {
	interval t;
	t.tmin = 0.0;
	t.tmax = 0.0;
	return t;
}
interval new_interval(float tmin, float tmax) {
	interval t;
	t.tmin = tmin;
	t.tmax = tmax;
	return t;
}
interval new_interval(interval a, interval b) {
	interval t;
	t.tmin = a.tmin <= b.tmin ? a.tmin : b.tmin;
	t.tmax = a.tmax >= b.tmax ? a.tmax : b.tmax;
	return t;
}
float size(interval self) {
	return self.tmax - self.tmin;
}
bool contains(interval self, float x) {
	return self.tmin <= x && x <= self.tmax;
}
bool surrounds(interval self, float x) {
	return self.tmin < x && x < self.tmax;
}

struct hit_record {
	vec3 p;
	vec3 normal;
	float t;
	float u;
	float v;
	bool front_face;
};
void set_face_normal(inout hit_record self, ray r, vec3 outward_normal) {
	self.front_face = dot(r.direction, outward_normal) < 0;
	self.normal = self.front_face ?outward_normal : -outward_normal;
}

struct sphere {
	vec3 center;
	float radius;
};
sphere new_sphere(vec3 position, float radius) {
	sphere s;
	s.center = position;
	s.radius = radius;
	return s;
}
bool hit_sphere(inout sphere s, inout ray r, interval ray_t, inout hit_record rec) {
	vec3 oc = s.center - r.origin;

	float a = length_squared(r.direction);
	float h = dot(r.direction, oc);
	float c = length_squared(oc) - s.radius * s.radius;
	float discriminant = h * h - a * c;
	
	if (discriminant < 0) {
		return false;
	}

	float sqrtd = sqrt(discriminant);

	// Find nearest root that lies in acceptable range
	float root = (h - sqrtd) / a;
	if (!surrounds(ray_t, root)) {
		root = (h + sqrtd) / a;
		if (!surrounds(ray_t, root)) {
			return false;
		}
	}

	rec.t = root;
	rec.p = at(r, rec.t);
	vec3 outward_normal = (rec.p - s.center) / s.radius;
	set_face_normal(rec, r, outward_normal);
	//rec.mat = mat;

	return true;
}

const int num_spheres = 2;
sphere spheres[num_spheres];

bool hit_sphere_list(ray r, interval ray_t, inout hit_record rec) {
	hit_record temp_hit;
	bool hit_anything = false;
	float closest_so_far = ray_t.tmax;

	for (int i = 0; i < num_spheres; i++) {
		if (hit_sphere(spheres[i], r, new_interval(ray_t.tmin, closest_so_far), temp_hit)) {
			hit_anything = true;
			closest_so_far = temp_hit.t;
			rec = temp_hit;
		}
	}

	return hit_anything;
}

struct camera {
	int image_width, image_height;  // Ratio of image width over height
	float aspect_ratio;				// Rendered image width in pixel count
	int samples_per_pixel;			// Number of random samples per pixel
	int max_bounces;				// Maximum times a ray can bounce off of geometry
	vec3 background_colour;			// Scene background colour

	float vfov;						// Vertical field of view
	vec3 lookfrom;					// Camera position
	vec3 lookat;					// Point camera is looking at
	vec3 vup;						// Camera relative up direction

	float defocus_angle;			// Variation angle of rays through each pixel
	float focus_dist;				// Distance from camera lookfrom point to plane of perfect focus

	float pixel_samples_scale;		// Colour scale factor for sum of pixel samples
	int sqrt_spp;					// Square root of number of samples per pixel
	float recip_sqrt_spp;			// 1 / sqrt_spp
	vec3 pixel00_loc;				// Location of pixel 0, 0
	vec3 pixel_delta_u;				// Offset to pixel to the right
	vec3 pixel_delta_v;				// Offset to pixel below
	vec3 u, v, w;					// Camera frame basis vectors
	vec3 defocus_disk_u;			// Defocus disk horizontal radius
	vec3 defocus_disk_v;			// Defocus disk vertical radius
};
uniform camera cam;
vec3 ray_colour(inout camera self, ray r) {
	hit_record rec;

	if (hit_sphere_list(r, new_interval(0.001, 1000000.0), rec)) {
		return 0.5 * (rec.normal + vec3(1.0));
	}

	vec3 unit_direction = normalize(r.direction);
	float a = 0.5 * (unit_direction.y + 1.0);
	return (1.0 - a) * vec3(1.0) + a * vec3(0.5, 0.7, 1.0);
}
vec3 sample_square_stratified(int s_i, int s_j, float recip_sqrt_spp) {
		// Returns vector to random point in square sub-pixel specified by grid indices s_i, s_j
		float px = ((s_i + fast_random()) * recip_sqrt_spp) - 0.5;
		float py = ((s_j + fast_random()) * recip_sqrt_spp) - 0.5;

		return vec3(px, py, 0.0);
}
vec3 defocus_disk_sample(inout camera self) {
	// Returns random point in camera focus disk
	vec3 p = fast_random_in_unit_disk();
	return self.lookfrom + (p.x * self.defocus_disk_u) + (p.y * self.defocus_disk_v);
}
ray get_ray(inout camera self, int i, int j, int s_i, int s_j) {
	// Construct ray originating from defocus disk and directed and randomly sampled point around pixel location i, j for stratified sample square s_i, s_j
	vec3 offset = sample_square_stratified(s_i, s_j, self.recip_sqrt_spp);
	vec3 pixel_sample = self.pixel00_loc
			+ ((i + offset.x) * self.pixel_delta_u)
			+ ((j + offset.y) * self.pixel_delta_v);
	
	vec3 ray_origin = (self.defocus_angle <= 0.0) ? self.lookfrom : defocus_disk_sample(self);
	vec3 ray_direction = pixel_sample - ray_origin;

	return new_ray(ray_origin, ray_direction);
}

void main() {
	// Scene
	spheres[0] = new_sphere(vec3(0.0, 0.0, -1.0), 0.5);
	spheres[1] = new_sphere(vec3(0.0, -100.5, -1.0), 100.0);

	camera Camera = cam;

	// Prepare trace
	vec3 pixel_colour = vec3(0.0);
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	int j = pixel_coords.y;
	int i = pixel_coords.x;

	// Begin trace
	for (int s_j = 0; s_j < Camera.sqrt_spp; s_j++) {
		for (int s_i = 0; s_i < Camera.sqrt_spp; s_i++) {
			ray r = get_ray(Camera, i, j, s_i, s_j);
			pixel_colour += ray_colour(Camera, r);
		}
	}
	pixel_colour = Camera.pixel_samples_scale * pixel_colour;

	// Output to image texture
	imageStore(screenImage, pixel_coords, vec4(pixel_colour, 1.0));
}