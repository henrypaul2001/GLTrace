#version 430 core
layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout (rgba32f, binding = 0) uniform image2D screenImage;

const uint max_world_size = 100;

struct ray {
	vec3 origin;
	vec3 direction;
};
ray new_ray(vec3 origin, vec3 direction) {
	ray r;
	r.origin = origin;
	r.direction = direction;
	return r;
}
vec3 at(ray r, float t) {
	return r.origin + t * r.direction;
}

struct sphere {
	vec3 center;
	float radius;
};
sphere new_sphere(vec3 position, float radius) {
	sphere s;
	s.center = position;
	s.radius = radius;
	return s;
}
bool hit_sphere(inout sphere s, inout ray r) {
	vec3 oc = s.center - r.origin;
	float a = dot(r.direction, r.direction);
	float b = -2.0 * dot(r.direction, oc);
	float c = dot(oc, oc) - s.radius * s.radius;
	float discriminant = b * b - 4 * a * c;
	
	return (discriminant >= 0);
}

sphere s;

struct camera {
	int image_width, image_height;  // Ratio of image width over height
	float aspect_ratio;				// Rendered image width in pixel count
	int samples_per_pixel;			// Number of random samples per pixel
	int max_bounces;				// Maximum times a ray can bounce off of geometry
	vec3 background_colour;			// Scene background colour

	float vfov;						// Vertical field of view
	vec3 lookfrom;					// Camera position
	vec3 lookat;					// Point camera is looking at
	vec3 vup;						// Camera relative up direction

	float defocus_angle;			// Variation angle of rays through each pixel
	float focus_dist;				// Distance from camera lookfrom point to plane of perfect focus

	float pixel_samples_scale;		// Colour scale factor for sum of pixel samples
	int sqrt_spp;					// Square root of number of samples per pixel
	float recip_sqrt_spp;			// 1 / sqrt_spp
	vec3 pixel00_loc;				// Location of pixel 0, 0
	vec3 pixel_delta_u;				// Offset to pixel to the right
	vec3 pixel_delta_v;				// Offset to pixel below
	vec3 u, v, w;					// Camera frame basis vectors
	vec3 defocus_disk_u;			// Defocus disk horizontal radius
	vec3 defocus_disk_v;			// Defocus disk vertical radius
};
void initCamera(inout camera self) {
	self.aspect_ratio = self.image_width / self.image_height;

	self.pixel_samples_scale = 1.0 / self.samples_per_pixel;
	self.sqrt_spp = int(sqrt(self.samples_per_pixel));
	self.pixel_samples_scale = 1.0 / (self.sqrt_spp * self.sqrt_spp);
	self.recip_sqrt_spp = 1.0 / self.sqrt_spp;

	// Determine viewport dimensions
	float theta = radians(self.vfov);
	float h = tan(theta / 2.0);
	float viewport_height = 2.0 * h * self.focus_dist;
	float viewport_width = viewport_height * (float(self.image_width) / self.image_height);

	// U, V, W basis vectors for coordinate frame
	self.w = normalize(self.lookfrom - self.lookat);
	self.u = normalize(cross(self.vup, self.w));
	self.v = cross(self.w, self.u);

	// Calculate viewport delta
	vec3 viewport_u = viewport_width * self.u;
	vec3 viewport_v = viewport_height * -self.v;

	// Pixel delta
	self.pixel_delta_u = viewport_u / self.image_width;
	self.pixel_delta_v = viewport_v / self.image_height;

	// Upper left coordinate
	vec3 viewport_upper_left = self.lookfrom - (self.focus_dist * self.w) - viewport_u / 2.0 - viewport_v / 2.0;
	self.pixel00_loc = viewport_upper_left + 0.5 * (self.pixel_delta_u + self.pixel_delta_v);

	// Camera defocus disk basis vectors
	float defocus_radius = self.focus_dist * tan(radians(self.defocus_angle / 2.0));
	self.defocus_disk_u = self.u * defocus_radius;
	self.defocus_disk_v = self.v * defocus_radius;
} // Move this to CPU and push values to GPU as uniforms before dispatch
vec3 ray_colour(inout camera self, ray r) {
	if (hit_sphere(s, r)) {
		return vec3(1.0, 0.0, 0.0);
	}

	vec3 unit_direction = normalize(r.direction);
	float a = 0.5 * (unit_direction.y + 1.0);
	return (1.0 - a) * vec3(1.0) + a * vec3(0.5, 0.7, 1.0);
}

void main() {
	// Scene
	camera cam;
	s = new_sphere(vec3(0.0, 0.0, -5.0), 2.5);

	// Setup camera
	cam.image_width = imageSize(screenImage).x;
	cam.image_height = imageSize(screenImage).y;
	cam.aspect_ratio = 1.0;
	cam.samples_per_pixel = 10;
	cam.max_bounces = 10;
	cam.background_colour = vec3(1.0, 0.5, 1.0);
	cam.vfov = 90.0;
	cam.lookfrom = vec3(0.0);
	cam.lookat = vec3(0.0, 0.0, -1.0);
	cam.vup = vec3(0.0, -1.0, 0.0);
	cam.defocus_angle = 0.0;
	cam.focus_dist = 10.0;
	initCamera(cam);
	
	// Prepare trace
	vec3 pixel_colour = vec3(0.0);
	ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
	uint j = pixel_coords.y;
	uint i = pixel_coords.x;
	vec3 pixel_center = cam.pixel00_loc + (i * cam.pixel_delta_u) + (j * cam.pixel_delta_v);
	vec3 ray_direction = pixel_center - cam.lookfrom;
	ray r = new_ray(cam.lookfrom, ray_direction);

	// Begin trace
	pixel_colour = ray_colour(cam, r);

	// Output to image texture
	imageStore(screenImage, pixel_coords, vec4(pixel_colour, 1.0));
}